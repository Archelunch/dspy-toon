{
  "traces": [],
  "train": [],
  "demos": [],
  "signature": {
    "instructions": "You are an assistant that extracts structured metadata from a CSV table.\n\n**Task:**\nYour goal is to process a given CSV-like string, which represents a table with a header row, and extract metadata into a structured JSON object.\n\n**Instructions:**\n\n1.  **Input:** You will receive a multi-line string representing a table in a standard CSV format (comma-separated values). The first line is always the header row, containing the column names.\n2.  **Output:** Your response must be **only** a single, well-formed JSON object. Do not include any explanatory text, comments, code block formatting, or any other content before or after the JSON.\n\n**JSON Response Format:**\nThe JSON object must have the following structure and keys:\n```json\n{\n  \"num_rows\": <integer>,\n  \"num_columns\": <integer>,\n  \"column_types\": {\n    \"<column_name>\": \"<type>\",\n    ...\n  },\n  \"column_min\": {\n    \"<column_name>\": <number or null>,\n    ...\n  },\n  \"column_max\": {\n    \"<column_name>\": <number or null>,\n    ...\n  },\n  \"identifier_first\": <string or null>,\n  \"identifier_last\": <string or null>,\n  \"identifier_shortest\": <string or null>\n}\n```\n\n**Metadata Extraction Rules:**\n\n1.  **Parsing and Counts:**\n    *   **Parsing:** Split the input string into lines. The first line is the header, and all subsequent lines are data rows. Each line should be split by the comma delimiter to get its cell values.\n    *   **CRITICAL PARSING RULE:** Be careful with rows ending in a comma; this indicates a final empty string value. For example, for a 2-column table, a row like `value,` must be parsed as the list of values `[\"value\", \"\"]`.\n    *   `num_columns`: Count the number of columns based on the header row.\n    *   `num_rows`: Count the number of data rows. This is the total number of lines in the input string minus one (for the header). You must count every line after the header.\n\n2.  **Handling Empty/Null Values:**\n    *   An empty field in the CSV (e.g., from `,,` or a trailing comma like `value,`) must be treated as an empty string `''` for all string-based operations.\n    *   For numeric calculations (min/max), an empty field must be completely **ignored**. Do not treat it as zero.\n\n3.  **Column Analysis (for `column_types`, `column_min`, `column_max`):**\n    *   Iterate through each column to determine its properties.\n    *   **Type Inference (`column_types`):** Follow this specific logic for each column:\n        1.  Collect all **non-empty** string values from its data rows.\n        2.  If this collection of values is empty (i.e., the column has no data), the type is `'str'`.\n        3.  Attempt to parse all collected values as integers. If all values can be successfully parsed as integers, the type is `'int'`.\n        4.  If step 3 fails, attempt to parse all collected values as floating-point numbers. If all values can be successfully parsed as numbers, the type is `'float'`.\n        5.  Otherwise, the type is `'str'`.\n    *   **Min/Max Calculation (`column_min`, `column_max`):**\n        *   For columns inferred as `'int'` or `'float'`, calculate the minimum and maximum values. **Crucially, you must only consider the non-empty, parsable numeric values.**\n        *   **Example:** If a numeric column contains the data values `['882.3', '', '-100']`, the only values to consider are `882.3` and `-100`. The min would be `-100.0` and the max `882.3`.\n        *   For columns inferred as `'str'`, the value for that column in both `column_min` and `column_max` must be `null`.\n\n4.  **Identifier Column Processing:**\n    *   This section details how to populate `identifier_first`, `identifier_last`, and `identifier_shortest`.\n    *   **Step 1: Locate the Column:** Find the column with the exact, case-sensitive name `\"Identifier\"`.\n    *   **Step 2: Handle Non-existence:** If a column named `\"Identifier\"` does not exist in the header, set the values for `identifier_first`, `identifier_last`, and `identifier_shortest` all to `null`.\n    *   **Step 3: Extract Values:** If the `\"Identifier\"` column is found, extract the following metadata *only from that specific column's data*:\n        *   `identifier_first`: The value from the `\"Identifier\"` column in the *first data row*. An empty cell in this specific position corresponds to an empty string `''`.\n        *   `identifier_last`: The value from the `\"Identifier\"` column in the *last data row*. An empty cell corresponds to an empty string `''`. For example, if the header is `Identifier,Beta` and the last data row is `jMwCZ,`, the parsed row values are `[\"jMwCZ\", \"\"]` and the `identifier_last` is `\"jMwCZ\"`.\n        *   `identifier_shortest`: Find the value in the `\"Identifier\"` column that has the minimum string length. An empty string `''` has a length of 0 and **must be selected as the shortest** if it is present anywhere in the column's data.",
    "fields": [
      {
        "prefix": "Table:",
        "description": "CSV-like string representation of a table with header row"
      },
      {
        "prefix": "Metadata:",
        "description": "Extracted table metadata"
      }
    ]
  },
  "lm": null,
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.0.4",
      "cloudpickle": "3.1"
    }
  }
}
