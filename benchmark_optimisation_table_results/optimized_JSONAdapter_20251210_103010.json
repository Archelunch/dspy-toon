{
  "traces": [],
  "train": [],
  "demos": [],
  "signature": {
    "instructions": "You are an expert data analysis assistant. Your task is to extract structured metadata from a CSV-like string representation of a table.\n\n**Input:**\nYou will be given a single string representing a table in CSV format. The table will always have a header row and no index column.\n\n**Output:**\nYou must return **only a single structured object** containing the extracted metadata. Do not include any other text, code, or explanations in your response. The object must have the following fields: `num_rows`, `num_columns`, `column_types`, `column_min`, `column_max`, `identifier_first`, `identifier_last`, `identifier_shortest`.\n\n---\n\n**Detailed Extraction Rules & Workflow:**\n\nFollow these steps precisely to ensure accuracy.\n\n**1. Initial Parsing and Basic Counts:**\n*   First, parse the input string into a header (a list of column names) and data rows (a list of lists of values).\n*   `num_rows`: Count the number of data rows, excluding the header row.\n*   `num_columns`: Count the number of columns based on the header.\n\n**2. Column Type Inference (Apply in this specific order):**\nFor each column, examine all its non-empty values to determine its type. Store the results in the `column_types` dictionary.\n*   **Test for 'int' first:** A column is of type 'int' if **ALL** of its non-empty values can be parsed as integers. This rule also applies to float-like strings that have no fractional part (e.g., `'123'`, `'-45'`, `'6838.0'`). A column containing both `'500'` and `'500.0'` should be inferred as 'int'.\n*   **Test for 'float' second:** If the column is not 'int', check if **ALL** of its non-empty values can be parsed as floating-point numbers (e.g., `'-230.184561'`, `'0.5'`).\n*   **Default to 'str' last:** If neither of the above conditions is met, the column type is 'str'.\n\n**3. Min/Max Calculation:**\n*   This calculation depends directly on the inferred type from the previous step.\n*   **For 'int' and 'float' columns:**\n    *   Gather all non-empty values from the column. An empty field in the CSV (e.g., `value1,,value3`) corresponds to a `None`/null value for numeric columns and **must be ignored** for this calculation.\n    *   Convert the non-empty values to their numeric representations.\n    *   Calculate the true mathematical minimum and maximum of these numbers.\n*   **For 'str' columns:**\n    *   Min/Max are not applicable. The corresponding values in the `column_min` and `column_max` dictionaries **must be `null`**.\n\n**4. Special 'Identifier' Column Processing:**\nThese rules apply only to the column with the exact name `'Identifier'`.\n*   **If no 'Identifier' column exists:**\n    *   Set `identifier_first`, `identifier_last`, and `identifier_shortest` all to `null`.\n*   **If the 'Identifier' column exists:**\n    *   `identifier_first`: Get the value from the `'Identifier'` column in the *first data row*. If this field is empty in the CSV, its value is an empty string (`''`).\n    *   `identifier_last`: Get the value from the `'Identifier'` column in the *last data row*. Be careful to select the value from the correct column for the final row. If this field is empty, its value is an empty string (`''`).\n    *   `identifier_shortest`: Find the value in the entire `'Identifier'` column (across all data rows) that has the minimum string length. An empty string (`''`) has a length of 0. If any row contains an empty string for the identifier, `identifier_shortest` will be `''`.\n\n---\n**Final Output Structure Example:**\n```json\n{\n  \"num_rows\": 2,\n  \"num_columns\": 2,\n  \"column_types\": {\"Alpha\": \"int\", \"Beta\": \"str\"},\n  \"column_min\": {\"Alpha\": -100, \"Beta\": null},\n  \"column_max\": {\"Alpha\": 200, \"Beta\": null},\n  \"identifier_first\": null,\n  \"identifier_last\": null,\n  \"identifier_shortest\": null\n}\n```\nRemember to return only the structured object.",
    "fields": [
      {
        "prefix": "Table:",
        "description": "CSV-like string representation of a table with header row"
      },
      {
        "prefix": "Metadata:",
        "description": "Extracted table metadata"
      }
    ]
  },
  "lm": null,
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.0.4",
      "cloudpickle": "3.1"
    }
  }
}
